Nina: Im Video unbedingt den Pipe-Operator und die gängigsten Funktionen (summarize, group_by etc...) und Power-Kombis vorstellen 
Frie: 
- die fünf / sechs Verben: filter, mutate, select, groupby summarize, arrange ganz am anfang und dann sich durchhangeln. groupby summarize eher rauslassen
- tidy data Konzepte (video): https://r4ds.had.co.nz/tidy-data.html (muss man ja nicht religiös nehmen, aber vieles ist schon sinnvoll)
- pivoting (tidyr)
- beim "zusammenfügen" dachte ich zuerst an bind_rows, nicht an joins. was in dem fall ja auch mehr sinn  machen würde oder? vlt kann man hier ncohmal konzeptionell unterscheiden zw "daten unten anhaengen " und "mehr variablen hinzufuegen aus einem anderen datensatz"?
- vlt kann man für joins dafür einen datensatz der Weltbank dazunehmen? irgendwas mit GDP per capita oder so? ich finde, so ist es etwas verwirrend, weil man den datensatz teilt und dann wieder zusammenführt . der fokus geht auch etwas verloren weil zuerst noch groupby summarized wird. was ich gut finde ist der gotcha mit den verschiedenen ländernamen - sehr lebensnah :D 
- weiß nicht ob ich den forward arrow so gut finde..ich verstehe die motivation dah inter aber bin mir nicht sicher ob es nicht mehr verwirrung stiftet

### Lernziele - Was Euch diese Woche erwartet!
- Was ist das **Tidyverse**? - Einsatz und Packages
- Wie können wir bestimmte Beobachtungen oder Variablen in einem Datensatz **filtern**?
- Mehr als ein Datensatz? - Wie wir mehrere **Datensätze zusammenfügen** können

### Kernaussagen

#### Das Tidyverse
<left>
![*Tidyverse](https://www.tidyverse.org/images/hex-tidyverse.png){#id .class width=20% height=100%}
</left>
<br>

- Das Tidyverse ist eine **Sammlung von verschiedenen R-Packages**, die aufeinander abgestimmt sind und dabei der selben Logik folgen ([tidyverse.org](https://www.tidyverse.org/){target="_blank"}). 
- Einige der Packages und Funktionen kennt Ihr bereits aus den letzten Wochen!
- Die Packages können einzeln installiert und aufgerufen werden, aber auch gesammelt über `install_packages('tidyverse')` bzw. `library(tidyverse)`. 
- Aber was macht einen **Datensatz tidy**?
  - Jede Variable hat eine eigene Spalte.
  - Jede Beobachtung hat eine eigene Zeile.
  - Jeder Wert hat eine eigene Zelle.
  
#### Die Pipe
- Die Pipe `%>%` wird verwendet, um eine Abfolge von Aktionen nacheinander durchzuführen.
- Um den Code übersichtlich zu halten, sollte dabei jede Funktion, die auf das Objekt angewendet wird, in einer eigenen Zeile stehen.

#### Die wichtigsten Funktionen des Tidyverse
- `dplyr::arrange`: Sortierung von Zeilen im Datensatz nach bestimmten Kriterien
- `dplyr::filter`: Auswahl von Zeilen bzw. Beobachtungen nach bestimmten Kriterien
- `dplyr::select`: Auswahl von Spalten bzw. Variablen
- `dplyr::mutate`: Erstellung neuer Spalten/Variablen auf Basis bereits vorhandener Spalten/Variablen
- `dplyr::group_by`: Gruppierung von Beobachtungen 
- `dplyr::summarize`: Berechnung von Kennwerten wie Mittelwerten etc.

#### Daten zusammenführen
Sehr wahrscheinlich werdet Ihr vor dem Problem stehen, dass Ihr Daten in mehreren unterschiedlichen Datensätzen vorliegen habt. Beispielsweise einen Datensatz pro Jahr oder auch Datensätze zu unterschiedlichen Themenbereichen. In dem Fall braucht Ihr Methoden, um die Daten zusammenzuführen: 

- `dplyr::xxxx_join` hilft Euch, wenn Ihr zwei Datensätze habt mit den gleichen oder zumindest sich überschneidenden Beobachtungen und Ihr die Variablen in einem Datensatz haben wollt.
- `dplyr::bind_rows` ist nützlich für Euch, wenn Ihr Zeilen an einen Datensatz anhängen wollt, d.h. weitere Beobachtungen mit den gleichen Variablen hinzufügen wollt.

### Interaktive Übung

Zuerst nochmal eine kleine Wiederholung: 

```{r 07quiz_datenbereinigung1}
quiz(caption = NULL,
  question("Welche dieser Packages sind Teil des Tidyverse?",
    answer("dplyr", correct = TRUE),
    answer("shiny"),
    answer("ggplot2", correct = TRUE),
    answer("readr", correct = TRUE),
    answer("haven"),
    correct = "Richtig!",
    incorrect = "Leider falsch: Versuche es einfach nochmal oder schau im Video nach!",
    allow_retry = TRUE,
    try_again_button = "Nochmal versuchen"
  )
)
```

#### Datenimport

Zuerst laden wir unseren Datensatz - das kennt Ihr ja bereits schon! Wie Ihr seht, verwenden wir hier das `readr` Package, welches auch ein Teil des `tidyverse` ist:

``` {r 07load_data, exercise = TRUE}

plastics <- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2021/2021-01-26/plastics.csv')

```

Nina: Das kannst Du auch weglassen, wenn du möchtest - für die Funktionalität des Abschnitts ist es nicht notwendig // Zoe: dachte es ist aber vielleicht ganz sinnvoll, den Weg vom Laden über Bereinigung zu kleiner Visualisierung einmal komplett zu zeigen?

#### Die Pipe `%>%`

Bei der ersten Einführung in R habt Ihr Euch die Funktion `nrow()` angeschaut, mit der Ihr herausfinden könnt, wie viele Zeilen ein Datensatz hat. Damals habt Ihr das mit `nrow(plastics)` gemacht, also `base R`, in der Zwischenzeit habt Ihr aber auch die **Pipe (%>%)** aus dem `tidyverse` kennengelernt. Nutzt daher einmal die Pipe, um Euch die Anzahl der Beobachtungen im Datensatz ausgeben zu lassen:

``` {r 07pipe, exercise = TRUE}
# Hier Euer Code!
```

```{r 07quiz_datenbereinigung2}
quiz(caption = NULL,
  question("Wie viele Zeilen hat Euer Datensatz plastics?",
    answer("14"),
    answer("13380", correct = TRUE),
    answer("15050"),
    answer("9876"),
    correct = "Gut gemacht!",
    incorrect = "Das ist leider nicht ganz richtig. Probiert es doch mal mit plastics %>% nrow().",
    allow_retry = TRUE,
    try_again_button = "Nochmal versuchen"
  )
)
```

#### Die Funktion `dplyr::arrange`

Um Euch einen Überblick über die Daten zu verschaffen, führt folgenden Code aus. Die Funktion `dplyr::arrange` **sortiert** dabei die Werte in der ausgewählten Spalte.

``` {r 07overview_data, exercise = TRUE}
# Ihr nehmt Euren Datensatz...
plastics %>%
  # ...erstellt eine Tabelle...
  janitor::tabyl(country, year) %>%
  # ...und sortiert die Werte für 2019 absteigend!
  dplyr::arrange(desc(`2019`))
```

```{r 07quiz_datenbereinigung3}
quiz(caption = NULL,
  question("In welchem Land gab es 2019 die meisten Plastik-Sammelaktionen?",
    answer("United States of America"),
    answer("Argentina"),
    answer("Philippines", correct = TRUE),
    correct = "Gut gemacht!",
    incorrect = "Das ist leider nicht ganz richtig. Probiert es nochmal!",
    allow_retry = TRUE,
    try_again_button = "Nochmal versuchen"
  )
)
```

#### Die Funktion `dplyr::filter`

Angenommen Ihr möchtet nun nur die Daten aus dem Jahr 2019, dann könnt Ihr das `dplyr` Package zum **Filtern von Zeilen bzw. Beobachtungen** verwenden. Mit der Funktion `dplyr::filter` könnt Ihr einen Datensatz unterteilen, wobei die Zeilen beibehalten werden, die die Bedingung(en) erfüllen, die Ihr definiert. Führt diesen Code aus, sodass Euer neuer Datensatz nur Daten aus 2019 enthält:

``` {r 07filter_data, exercise = TRUE}
plastics_2019 <- plastics %>%
  dplyr::filter(year == "2019") 

```

Jetzt seid Ihr dran! Erstellt aus `plastics` nun noch einen Datensatz `plastics_2020`, der nur die Daten aus dem Jahr 2020 enthält: 
``` {r 07filter_data_exercise, exercise = TRUE}
# Hier Euer Code!


```

Nutzt den folgenden Codeblock, um herauszufinden, in welchem der beiden Jahre 2019 oder 2020 es die größere Anzahl an Plastik-Sammelaktionen gab: 
``` {r 07filter_data_exercise2, exercise = TRUE}
# Hier Euer Code!


```

```{r 07quiz_datenbereinigung4}
quiz(caption = NULL,
  question("In welchem Jahr gab es mehr Plastik-Sammelaktionen?",
    answer("2019", correct = TRUE),
    answer("2020"),
    correct = "Gut gemacht!",
    incorrect = "Das ist leider nicht ganz richtig. Probiert es nochmal!",
    allow_retry = TRUE,
    try_again_button = "Nochmal versuchen"
  )
)
```

#### Die Funktion `dplyr::select`

Neben Zeilen bzw. Beobachtungen könnt Ihr aber natürlich auch **Spalten bzw. Variablen filtern**. Auch hier hilft Euch das `dplyr` Package mit der Funktion `select` wieder weiter. Mit `select` könnt Ihr entweder die Variablen auswählen, die im Datensatz enthalten sein sollen oder aber mit einem `-` die Variablen auswählen, die aus Eurem Datensatz gelöscht werden sollen. Der folgende Code löscht so zum Beispiel die Variable `grand_total` aus dem `plastics_2019`-Datensatz:

``` {r 07select_data1, exercise = TRUE}
plastics_reduced <- plastics_2019 %>%
  dplyr::select(-grand_total)
```

Führt den folgenden Code aus, um Euch alle im Datensatz enthaltenen Variablen anzeigen zu lassen. Wie Ihr seht: `grand_total` ist nicht mehr enthalten!

``` {r 07select_data2, exercise = TRUE}
plastics_reduced %>%
  names()
```

#### Die Funktion `dplyr::mutate`

Wie Ihr vielleicht schon wisst, ist die Variable `grand_total` einfach nur die Summe an Plastik, die sich aus den anderen Plastik-Kategorien im Datensatz zusammensetzt. Deshalb könnt Ihr die eben gelöschte **Variable** wieder leicht in Euren Datensatz **einfügen**: 

``` {r 07mutate1, exercise = TRUE}
# Ihr nehmt Euren Datensatz,...
plastics_reduced %>%
  # ...erstellt die neue Variable,...
  dplyr::mutate(grand_total = hdpe + ldpe + o + pet + pp + ps + pvc
                # ...wählt aus, wo diese im Datensatz eingefügt werden soll...
                , .after = pvc) %>%
  # ...und lasst Euch die ersten Zeilen des Datensatzes einmal anzeigen - passt!
  head()
```

Natürlich kann die neue Variable auch aus anderen Variablen erstellt werden, die dann direkt aus dem Datensatz entfernt werden:

``` {r 07mutate2, exercise = TRUE}
# Ihr nehmt Euren Datensatz,...
plastics_reduced %>%
  # ...erstellt die neue Variable,...
  dplyr::mutate(grand_total = hdpe + ldpe + o + pet + pp + ps + pvc,
         # ...wählt aus, wo diese im Datensatz eingefügt werden soll,...
         .after = pvc,
         # ...gebt an, dass verwendete Variablen gelöscht werden können...
         .keep = "unused"
         ) %>%
  # ...und lasst Euch die ersten Zeilen des Datensatzes einmal anzeigen - passt!
  head()
```

#### Die Funktionen `dplyr::group_by` und `dplyr::summarize`
Interessant ist es natürlich auch, die Daten nach Ländern zu **gruppieren**. Dabei helfen Euch die Funktionen `group_by` und `summarize` aus dem `dplyr`-Package. Das kommt Euch aus dem Kapitel  "Erste Datenanalysen mit R" vielleicht noch bekannt vor, dort habt Ihr nach Kontinenten gruppiert - hier jetzt einmal für die Länder, denn Übung macht den Meister! Bevor Ihr die Funktionen anwendet, müsst Ihr allerdings noch eine Kleinigkeit im Datensatz filtern - ist Euch aufgefallen, dass in der Spalte `parent_company` auch das Grand Total für die Länder angegeben ist? Dieses soll bei der Gruppierung ja nicht mitaggregiert werden, daher müsst Ihr diese zuerst filtern. Führt dazu die folgenden Codeblöcke aus:

``` {r 07group_by_summarize1, exercise = TRUE}
# Ihr nehmt Euren Datensatz,...
reduced_2019 <- plastics_2019 %>%
  # ...löscht die Grand Total Zeilen und EMPTY-Zeilen,...
  dplyr::filter(parent_company != "Grand Total" 
                & country != "EMPTY") %>%
  # ...gruppiert die Daten nach Ländern,...
  dplyr::group_by(country) %>%
  # ...und aggreggiert die Daten für die einzelnen Länder
  dplyr::summarize(grand_total = sum(grand_total),
                   num_events = mean(num_events),
                   volunteers = mean(volunteers))
# Check:
reduced_2019 %>% 
  head()
```

``` {r 07group_by_summarize2, exercise = TRUE}
# Und das selbe für 2020:
plastics_2020 %>%
  dplyr::filter(parent_company != "Grand Total"
                & country != "EMPTY") %>%
  dplyr::group_by(country) %>%
  dplyr::summarize(grand_total = sum(grand_total),
                   num_events = mean(num_events),
                   volunteers = mean(volunteers))
```

#### Datensätze zusammenfügen

Häufig ist es auch der Fall, dass mehrere Datensätze zu einem zusammengefügt werden sollen. Von der Weltbank habt Ihr nun noch einen Datensatz zum GDP pro Kopf (https://data.worldbank.org/indicator/NY.GDP.PCAP.CD?end=2020&start=2019), der unter `gdppc` gespeichert ist. Verschafft euch zuerst einen kleinen Überblick über den Datensatz: 

``` {r 07gdppc, exercise = TRUE}
# Hier Euer Code!

```

Da Ihr Euch im Folgenden nur das Jahr 2019 anschauen werdet, könnt Ihr alle anderen Jahre mit diesem Code aus dem Datensatz entfernen: 
``` {r 07gdppc_select, exercise = TRUE}
gdppc_reduced <- gdppc %>% 
  dplyr::select(country_name = 'Country Name',
                country_code = 'Country Code',
                gdp_2019 = '2019'
                )
gdppc_reduced %>%
  head()
```

Versucht jetzt einmal herauszufinden, wie viele Länder in beiden Datensätzen `gdppc_reduced` und `reduced_2019` vorhanden sind (hier führen viele Wege zum Ziel!):

``` {r 07nrow_ex, exercise = TRUE}
# Hier Euer Code!

```

```{r 07quiz_datenbereinigung5}
quiz(caption = NULL,
  question("Wie viele Länder sind im gdppc_reduced-Datensatz?",
    answer("3"),
    answer("266", correct = TRUE),
    answer("51"),
    answer("4084"),
    correct = "Gut gemacht!",
    incorrect = "Das ist leider nicht ganz richtig. Probiert es nochmal!",
    allow_retry = TRUE,
    try_again_button = "Nochmal versuchen"
  )
)
```

```{r 07quiz_datenbereinigung6}
quiz(caption = NULL,
  question("Wie viele Länder sind im reduced_2019-Datensatz?",
    answer("51", correct = TRUE),
    answer("4"),
    answer("9296"),
    answer("4084"),
    correct = "Gut gemacht!",
    incorrect = "Das ist leider nicht ganz richtig. Probiert es nochmal!",
    allow_retry = TRUE,
    try_again_button = "Nochmal versuchen"
  )
)
```

Um die Datensätze zusammenzuführen, braucht Ihr eine gemeinsame Variable, anhand der R die Länder einander zuordnen kann. Da der ausgeschriebene Ländername teilweise unterschiedlich sein kann, fügt Ihr zum `reduced_2019`-Datensatz erst einmal die Country Codes hinzu:

``` {r 07gdppc_country, exercise = TRUE}
data_2019 <- reduced_2019
data_2019$country_code <- countrycode::countrycode(data_2019$country, origin = 'country.name', destination = 'wb')
data_2019 %>% 
  head()
```

Jetzt - endlich - könnt Ihr die beiden Datensätze zusammenfügen. Dabei gibt es verschiedene Möglichkeiten, denn in dem einen Datensatz kommen viel mehr Länder vor als im anderen:

- `inner_join`: nur die Länder werden beibehalten, die in beiden Datensätzen enthalten sind
- `full_join`: alle Länder aus beiden Datensätzen sind enthalten
- `left_join`/`right_join`: nur die Länder aus dem zuerst bzw. zuletzt genannten Datensatz bleiben enthalten

![](https://d33wubrfki0l68.cloudfront.net/aeab386461820b029b7e7606ccff1286f623bae1/ef0d4/diagrams/join-venn.png){#id .class width=80% height=100%}

Führt die folgenden Codeblöcke nacheinander aus und schaut Euch an, wie diese verschiedenen Joins für Euren Datensatz in der Praxis funktionieren:

``` {r 07inner_join, exercise = TRUE}
# Ihr nehmt Euren ersten Datensatz...
data_2019 %>%
  # ...führt den Join aus...
  dplyr::inner_join(gdppc_reduced, by = "country_code") %>% 
  # ...und lasst die ersten Zeilen anzeigen
  head()
```

``` {r 07full_join, exercise = TRUE}
# Ihr nehmt Euren ersten Datensatz...
data_2019 %>%
  # ...führt den Join aus...
  dplyr::full_join(gdppc_reduced, by = "country_code") %>% 
  # ...und lasst die ersten Zeilen anzeigen
  head()
```

``` {r 07left_join, exercise = TRUE}
# Ihr nehmt Euren ersten Datensatz...
data_2019 %>%
  # ...führt den Join aus...
  dplyr::left_join(gdppc_reduced, by = "country_code") %>%
  # ...und lasst die ersten Zeilen anzeigen
  head()
```

``` {r 07right_join, exercise = TRUE}
# Ihr nehmt Euren ersten Datensatz...
data_2019 %>%
  # ...führt den Join aus...
  dplyr::right_join(gdppc_reduced, by = "country_code") %>%
  # ...und lasst die ersten Zeilen anzeigen
  head()
```

```{r 07quiz_datenbereinigung8}
quiz(caption = NULL,
  question("Wie Ihr sehen könnt, führt der full_join natürlich zu den meisten Zeilen im Datensatz und der inner_join zur geringsten Anzahl an Ländern. Welcher der beiden anderen Joins führt zu einer höheren Anzahl an Ländern im Datensatz?",
    answer("left_join"),
    answer("right_join", correct = TRUE),
    correct = "Gut gemacht!",
    incorrect = "Das ist leider nicht ganz richtig. Probiert es nochmal!",
    allow_retry = TRUE,
    try_again_button = "Nochmal versuchen"
  )
)
```

#### Visualisierungen
Zum Tidyverse gehört natürlich auch das `ggplot2`-Package, damit hattet ihr vor zwei Wochen bereits schicke Visualisierungen erstellt - mehr dazu lernt Ihr dann in den kommenden Wochen! 


### Exkurs: String Manipulation
Natürlich habt Ihr auch die Möglichkeit, Strings zu verändern, in Eurem Beispiel könnte man die Namen der Länder verändern, mit dem Ziel die Daten zu bereinigen. Beispielsweise ist im Datensatz `reduced_2019` Taiwan als "Taiwan_ Republic of China (ROC)" eingetragen und Nigeria in Großbuchstaben geschrieben. Dafür hat das `stringr`-Package aus dem Tidyverse die Funktion `str_replace`:

``` {r 07strings1, exercise = TRUE}
reduced_2019 %>%
  mutate(country = str_replace(country, 'Taiwan_ Republic of China (ROC)', 'ROC'),
         country = str_to_title(country)
         )
```

@me: DAS FUNKTIONIERT SO NOCH NICHT?!

Wenn es etwas komplizierter sein sollte, dann könnt Ihr auch Regex (Regular Expressions) verwenden, um Strings zu manipulieren. Hier findet ihr ein gutes [Cheatsheet](https://cheatography.com/davechild/cheat-sheets/regular-expressions/){target="_blank"} mit den wichtigsten Symbolen und ihrer Bedeutung. 
  
### Und jetzt Ihr

