Was w√§re eine Welt ohne interaktive und zug√§ngliche Visualisierungen? Vielleicht habt Ihr es schon in den Online-Ausgaben von Zeitungen gesehen und seid neugierig, wie man so etwas auch leicht selbst machen kann? Dann seid Ihr bei Shiny-Apps genau richtig! 

Im Video erfahrt Ihr, was es mit Shiny-Apps auf sich hat und wie es genau funktioniert.

![](VIDEO) (ca. 15-20 Minuten) 
*Notiz an mich: Slide mit Beispielen von Shiny-Apps bringen; kurz Server und UI erkl√§ren und erkl√§ren, wie sie zusammenh√§ngen*
*ich erkl√§re es im Text unten nochmal, da es ein so wichtiger und zentraler Bestandteil einer Shiny-App ist*

### Kernaussagen 

- **Shiny-Apps** sind Webapplikationen
  - Man kann damit **Daten**, **Visualisierungen**, oder auch allgemein **Informationen** "verpacken" und so interaktiv f√ºr andere Nutzer zur Verf√ºgung stellen
  - Eine Shiny-App kann man sp√§ter leicht **hosten** und so auch **ohne Code zug√§nglich** machen
- Eine Shiny-App besteht immer aus einer **UI** und einem **Server**
  - Die **UI** stellt das User Interface oder auch den K√∂rper der App dar
  - Hier k√∂nnt Ihr Eure App optisch anpassen und die Anordnung der einzelnen Komponenten definieren
  - Der **Server** bietet den Ort f√ºr die Verrechnung (oder auch Erstellung) der Visualisierungen - er ist also quasi das Gehirn der Shiny-App
  - Ihr definiert den **Server** und die **UI** separat und legt beides in verschiedenen Objekten (`server` und `ui`) ab
- Wenn Ihr Eure Shiny-App zum Laufen bringen wollt, f√ºhrt Ihr `ui` und `server` in folgender Funktion zusammen: `shinyApp(ui = ui, server = server)`

F√ºr weitere Infos zu Shiny-App, schaut Euch den [**Schummelzettel zu Shiny-Apps**](daten/cheat sheets/shiny_de.pdf){target="_blank"} an.

Bevor es losgeht, noch ein paar kurze Fragen:

```{r 11ui}
quiz(caption = NULL,
  question("Was macht das UI (user interface) einer Shiny-App?",
    answer("Eine UI bestimmt das Aussehen der Shiny-App", correct = TRUE),
    answer("Eine UI ist in der Shiny-App f√ºr das Deployen zust√§ndig."),
    answer("Eine UI legt fest, wo welche Komponente der Shiny-App dargestellt wird", correct = TRUE),
    answer("In einer UI kann der Programmierer das Design der Shiny-App festlegen.", correct = TRUE),
    answer("Eine UI nimmt die gesamten Rechenoperationen im Hintergrund vor."),
    correct = "Richtig!",
    incorrect = "Leider falsch: Versuche es einfach nochmal oder schau im Video nach!",
    allow_retry = TRUE,
    try_again_button = "Nochmal versuchen"
  )
)
```

```{r 11server}
quiz(caption = NULL,
  question("Wof√ºr ist der Server in einer Shiny-App??",
    answer("Der Server ist in der Shiny-App f√ºr das Deployen zust√§ndig."),
    answer("Der Server legt fest, wo welche Komponente der Shiny-App dargestellt wird"),
    answer("Im Server wird der Code (z.B. zur Visualisierung) abgelegt.", correct = TRUE),
    answer("Der Server ist quasi das 'Gehirn' der Shiny-App und √ºbernimmt die ganze Rechenleistung im Hintergrund.", correct = TRUE),
    answer("Der Server ist kein Bestandteil einer Shiny-App."),
    correct = "Richtig!",
    incorrect = "Leider falsch: Versuche es einfach nochmal oder schau im Video nach!",
    allow_retry = TRUE,
    try_again_button = "Versucht es nochmal"
  )
)
```


### Was sind Shiny-Apps?

Wie Ihr im Video gesehen habt, sind Eurer Phantasie sind keine Grenzen gesetzt! Man kann Shiny-App zur Visualisierung, als Suchmaschine oder aber auch, um Euch automatisiert die Reports aus der letzten Sitzung erstellen zu lassen. In diesem Kurs lernt Ihr die Grundkenntnisse, um Eure erste eigene Anwendung (auf Englisch "application", daher auch "Shiny-App") zu bauen. Wenn Ihr mehr Inspiration m√∂chtet, schaut in der [Gallerie von RStudio](https://shiny.rstudio.com/gallery/){target="_blank"} vorbei!

### Wie funktioniert eine Shiny-App genau? 

<left>
![*Shiny](https://d33wubrfki0l68.cloudfront.net/d08c35bfe1ba68584788f5cdcad703d0c9d8263f/7969a/wp-content/uploads/2014/04/shiny.png){#id .class width=20% height=100%}

R liefert ein eigenes Package, `shiny`, um eine Shiny-App zu bauen. Bevor wir starten, installieren wir das Package:

```{r package_prep_shiny, exercise = TRUE}
# install.packages("shiny")
library(shiny)
```

Der [Schummelzettel](daten/cheat sheets/shiny_de.pdf){target="_blank"} liefert Euch einen guten √úberblick √ºber alle Komponenten und die wichtigsten Befehle zum Erstellen einer Shiny-App. Im Video habt Ihr bereits die Grundkomponenten kennen gelernt, die jede Shiny-App ben√∂tigt: **eine UI** (kurz f√ºr "**u**ser **i**nterface", Englisch f√ºr "Benutzeroberfl√§che") und **einen Server**. 

![](https://github.com/CorrelAid/lernplattform/blob/main/daten/abbildungen/app7.png?raw=true){#id .class width=70% height=70%}</right>

In einer Shiny-App habt Ihr meist zwei separate Bl√∂cke, einen `ui`-Part und einen `server`-Part, die Ihr dann mit dem Befehl **`shinyApp(ui = ui, server = server)`** zusammenbringt und Eure Shiny-App zum Laufen bringt. Da die **UI** und der **Server** die zentralen Bestandteile der Shiny-App sind, hier noch einmal in K√ºrze das Wichtigste:

<right>![](https://github.com/CorrelAid/lernplattform/blob/main/daten/abbildungen/brain.png?raw=true){#id .class width=20% height=100%}</right>

Zun√§chst betrachten wir das **Gehirn**, oder auch die Schaltzentrale der Shiny-App: den **Server**. Das Beispiel zeigt die standardm√§√üige Shiny-App, die Euch RStudio generiert, sobald Ihr eine Shiny-App startet. Wenn Ihr die Shiny-App in Aktion sehen wollt, k√∂nnt Ihr sie euch [**hier**](https://cosima-meyer.shinyapps.io/example_app/){target="_blank"} ansehen.

Die `server` Datei daf√ºr kann so aussehen:

```{r server, exercise=TRUE, context="server"}
# Dieser Code definiert die Serverlogik, um ein Histogramm zu visualisieren
# Der Server nimmt zwei Argumente `input` und `output`
server <- function(input, output) {

    # Wir speichern unsere Visualisierung in `output$distPlot` und werden `distPlot`
    # sp√§ter auch in der UI nutzen, um auf die Visualisierung zu referieren
    output$distPlot <- renderPlot({
      
        # Im n√§chsten Schritt bereiten wir die Daten f√ºr das Histogramm vor
        x    <- faithful[, 2]
        bins <- seq(min(x), max(x), length.out = input$bins + 1)

        # Und erstellen das Histogramm (wir k√∂nnen hier noch Farben bestimmen - das
        # sind aber alles optionale Argumente)
        hist(x, breaks = bins, col = 'darkgray', border = 'white')
    })
}
```

<!-- Der `server`-Part erlaubt es Euch, das "Gehirn" der Shiny-App zu programmieren.  -->

![](https://github.com/CorrelAid/lernplattform/blob/main/daten/abbildungen/body.png?raw=true){#id .class width=20% height=100%}

Im n√§chsten Schritt k√∂nnt Ihr das Aussehen Eurer App bestimmen. Dazu nutzen wir die `ui`, die zum Beispiel so aussehen kann:

```{r ui, exercise=TRUE}
# Hier bestimmen wir die UI
ui <- fluidPage(

    # Ihr k√∂nnt Eurer App einen Titel geben
    titlePanel("Old Faithful Geyser Data"),

    # Oder einen Slider einbauen
    sidebarLayout(
        sidebarPanel(
            sliderInput("bins",
                        "Number of bins:",
                        min = 1,
                        max = 50,
                        value = 30)
        ),

        # Und letztlich integrieren wir noch Eure Visualiserung - 
        # erinnert Ihr Euch noch an `distPlot`? Das kommt hier zum Einsatz :-)
        mainPanel(
           plotOutput("distPlot")
        )
    )
)
```

*Noch einmal in K√ºrze*: Die `ui`, oder auch *User Interface*, stellt die Benutzeroberfl√§che einer Shiny-App dar und erm√∂glicht es dem Nutzer die Shiny-App letztendlich zu bedienen. Im Video haben wir die `ui` den **K√∂rper** genannt und den `server` das **Gehirn**. Genauso kann man es sich auch vorstellen: Im Gehirn, also dem `server`, findet die gesamte Berechnung im Hintergrund statt. Das `ui` zeigt dann hinterher das Ergebnis an und l√§sst Euch die Shiny-App bedienen..

Und im letzten Schritt bringen wir die Shiny-App nat√ºrlich noch zusammen.

```{r shinyApp, exercise=TRUE}
# Wir kombinieren mit dem folgenden Befehl die UI und den Server und bringen
# die Shiny-App lokal zum Laufen :-)
shinyApp(ui = ui, server = server)
```

Hier ist die Shiny-App f√ºr Euch - klickt auf den Link und schaut Euch an, was der Code generiert hat:

![](){target="_blank"} **Host app**

Ihr k√∂nnt in einer Shiny-App Eure bisherigen Kenntnisse nutzen und zum Beispiel eine Visualisierung erstellen. Nehmen wir einmal die Visualisierung aus der letzten Woche als Beispiel: 

```{r plot_full_to_print, echo = FALSE}
# Wir definieren den Dateninput (`community`) 
community %>%
  # Datenbereinigung
  dplyr::filter(continent != "Unknown") %>% 
  # √úberschreiben eine vorherrschende Gruppierung
  ungroup() %>%
  # Berechnen die absolute Anzahl an Freiwilligen
  dplyr::mutate(absolute_anzahl = sum(volunteers)) %>%
  # Gruppieren nach Kontinent
  group_by(continent) %>%
  # Berechnen die relative Anzahl der Freiwilligen
  dplyr::mutate(relative_anzahl = (sum(volunteers) / absolute_anzahl) * 100) %>%
  # Behalten jeden Wert pro Kontinent nur einmal
  distinct(continent, relative_anzahl)  %>%
  # Initialisieren `ggplot2` und bestimment die x-Achse (Kontinente)
  # und die y-Achse (relative Anzahl an Freiwillien)
  # Zus√§tzlich legen wir die Farbe der Balken fest
  ggplot2::ggplot(aes(x = continent, y = relative_anzahl, fill = continent)) +
  # Definieren den Visualisierungsplot (Balkendiagramm)
  geom_col() +
    # Bezeichnung des Titels und des Untertitels
  labs(
    title = "Prozentuale Verteilung der Freiwilligen" ,
    subtitle = "pro Kontinent",
  ) +
  # Farben der Balken festlegen (√ºber das wesanderson Package)
  scale_fill_manual(values = wes_palette("Cavalcanti1")) +
  # Legen das Thema fest
  ggthemes::theme_wsj() +
  # Benennen die Legende um
  # Da wir hier wieder auf das `theme` zugreifen, ist es wichtig, dass es nach 
  # der Festlegung des Themas geschieht
  theme(legend.title = element_blank(),
        text = element_text(size=7))
```

Hier ist noch einmal der Code als Erinnerung daf√ºr - wir brauchen ihn gleich:

```{r plot_full, exercise = TRUE}
# Wir definieren den Dateninput (`community`) 
community %>%
  # Datenbereinigung
  dplyr::filter(continent != "Unknown") %>% 
  # √úberschreiben eine vorherrschende Gruppierung
  ungroup() %>%
  # Berechnen die absolute Anzahl an Freiwilligen
  dplyr::mutate(absolute_anzahl = sum(volunteers)) %>%
  # Gruppieren nach Kontinent
  group_by(continent) %>%
  # Berechnen die relative Anzahl der Freiwilligen
  dplyr::mutate(relative_anzahl = (sum(volunteers) / absolute_anzahl) * 100) %>%
  # Behalten jeden Wert pro Kontinent nur einmal
  distinct(continent, relative_anzahl)  %>%
  # Initialisieren `ggplot2` und bestimment die x-Achse (Kontinente)
  # und die y-Achse (relative Anzahl an Freiwillien)
  # Zus√§tzlich legen wir die Farbe der Balken fest
  ggplot2::ggplot(aes(x = continent, y = relative_anzahl, fill = continent)) +
  # Definieren den Visualisierungsplot (Balkendiagramm)
  geom_col() +
    # Bezeichnung des Titels und des Untertitels
  labs(
    title = "Prozentuale Verteilung der Freiwilligen" ,
    subtitle = "pro Kontinent",
  ) +
  # Farben der Balken festlegen (√ºber das wesanderson Package)
  scale_fill_manual(values = wes_palette("Cavalcanti1")) +
  # Legen das Thema fest
  ggthemes::theme_wsj() +
  # Benennen die Legende um
  # Da wir hier wieder auf das `theme` zugreifen, ist es wichtig, dass es nach 
  # der Festlegung des Themas geschieht
  theme(legend.title = element_blank(),
        text = element_text(size=7))
```

Wenn wir diese Abbildung in unsere Shiny-App integrieren wollen, k√∂nnen wir einfach den Code in die Shiny-App-Komponenten kopieren. Unser Ziel ist es eine lokale Shiny-App zu bauen, die so aussehen wird:

![](https://cosima-meyer.shinyapps.io/break_free_from_plastic/){target="_blank"} 

Probiert die App doch einfach aus. Wie Ihr sehen werdet, k√∂nnt Ihr innerhalb der Shiny-App nach Kontinenten filtern und wir sehen auch auf einmal, dass Ozeanien auch Freiwillige hat - eben nur sehr wenige!

```{r quizz_ap}
quiz(caption = NULL,
  question("Wie viele Freiwillige gibt es in Ozeanien (in %)?",
    answer("ca. 0%"),
    answer("ca. 20%"),
    answer("ca. 0.007", correct = TRUE),
    answer("ca. 2%"),
    answer("ca. 0.0001%"),
    correct = "Richtig!",
    incorrect = "Leider falsch: Versucht es einfach nochmal oder schaut Euch die Shiny-App noch einmal an!",
    allow_retry = TRUE,
    try_again_button = "Nochmal versuchen"
  )
)
```


Aber von Anfang an: Als Erstes sollte man sich beim Entwerfen einer Shiny-App einen groben Plan zurechtlegen. Meine Erfahrung hat gezeigt, dass es am besten ist, so simpel wie m√∂glich anzufangen. Eine Shiny-App kann man nach Belieben immer weiter erweitern und komplexer machen.

#### 1. Shiny-App planen

Im ersten Schritt, planen wir die Shiny-App. In unserem Fall sollte sie in etwa so aussehen:

![](https://github.com/CorrelAid/lernplattform/blob/main/daten/abbildungen/sketch_app.png?raw=true){#id .class width=70% height=70%} 

Wenn Ihr die App ausprobieren m√∂chtet, k√∂nnt Ihr das noch einmal [**hier**](https://cosima-meyer.shinyapps.io/break_free_from_plastic/){target="_blank"} machen.

Im Idealfall haben wir also die die Visualisierung des Balkendiagramms aus der letzten Woche in der Mitte. In der linken Seitenleiste seht Ihr Auswahlm√∂glichkeiten nach Kontinenten - d.h. wir k√∂nnen hinterher in unserer Shiny-App die Darstellung nach den Kontinenten filtern. Abschlie√üend geben wir der App noch einen passenden Namen, z.B. "Break Free From Plastic".

Nachdem wir unsere Shiny-App grob skizziert haben (ein Schritt, der wirklich hilfreich ist! Es hilft uns nicht nur unsere Idee zu visualisieren; es gibt uns auch eine "Bauanleitung", an der wir uns visuell orientieren und L√∂sungen suchen k√∂nnen!), bearbeiten wir das "Innere" der App: den **Server**, also den Ort, an dem die ganzen Berechnungen stattfinden, und die **UI**, also das Aussehen der Shiny-App.

Da wir auf dieser Plattform keine Shiny-App direkt programmieren k√∂nnen, haben wir Euch hier die Code-Snippets zusammengestellt und erkl√§ren Euch die einzelnen Schritte. Um die Shiny-App w√§hrend der Sitzung mitzubauen, haben wir Euch die Datei `app.R` vorbereitet. Die Datei k√∂nnt Ihr Euch wie einen "L√ºckentext" vorstellen, an dem Ihr an den entsprechenden Stellen den Code einf√ºgt und abschlie√üend Eure Shiny-App lokal laufen lasst! 

*Anmerkung: Solltet Ihr nicht weiterkommen, haben wir auch eine `app_loesung.R`-Datei f√ºr Euch vorbereitet.*

#### 2. Der Server

F√ºr den Server k√∂nnen wir unseren Code von oben in die `server.R`-Datei kopieren und entsprechend anpassen. Machen wir das doch einmal zusammen. Die Grundstruktur des Servers sieht so aus:

![](https://github.com/CorrelAid/lernplattform/blob/main/daten/abbildungen/app4.png?raw=true){#id .class width=70% height=70%}

Angewandt auf unseren Code w√§re das wiefolgt:

```{r server_new_plot, exercise=TRUE}
server <- function(input, output) {

    # Wir speichern unsere Visualisierung in `output$balkendiagramm`
    output$balkendiagramm <- renderPlot({
      
    # Innerhalb von `renderPlot()` kreieren wir unseren ggplot2
    # Erg√§nzt den Code unseres Balkendiagramms hier
      
      
    })
}
```

Der Server nimmt zwei Argumente: `input` und `output`. Wichtig ist hier, dass wir alle erzeugten Komponenten der Shiny-App an `output` anh√§ngen, um darauf sp√§ter in der `ui` darauf zugreifen zu k√∂nnen. Wenn wir zum Beispiel eine Visualisierung erzeugen, k√∂nnen wir es `output$balkendiagramm` nennen.

Nehmt den Code von oben und erg√§nzt ihn an der angegebenen Stelle im Server. Da wir in dieser Umgebung keine Shiny-App programmieren k√∂nnen, nutzen wir dazu eine lokale R-Datei. √ñffnet daf√ºr die Datei `app.R`. Erg√§nzt den Code des Balkendiagramms im Server an der Stelle, die mit `# 1. Aufgabe` markiert ist. In der `app.R`-Datei sieht es so aus:

```{r aufgabe_1, exercise=TRUE}
server <- function(input, output) {
  
  # Wir speichern unsere Visualisierung in `output$balkendiagramm`
  # Nutzt die geeignete Funktion (in diesem Fall renderPlot, da wir einen
  # Plot darstellen m√∂chten), um den Output zu generieren
  
  output$balkendiagramm <- renderPlot({
    
    ##########################################################################
    # 1. Aufgabe:
    # Innerhalb von `renderPlot()` kreieren wir unseren ggplot2
    # Hierf√ºr k√∂nnen wir unseren Code kopieren, den wir in der letzten
    # Sitzung erstellt haben
    ##########################################################################
    
    
  })
}
```

Als kurze Anmerkung: Wir haben hier `renderPlot` genommen, da wir einen Plot, also eine Visualisierung vornehmen. Wenn Ihr allerdings einen Text oder eine Tabelle einf√ºgen wollt, m√ºsst Ihr entsprechend eine andere Funktion nehmen. Die Tabelle stellt Euch die wichtigsten Befehle gegen√ºber:

| **Was m√∂chtet Ihr darstellen?**                                       | **Befehl in R f√ºr den `server`**                     |
|-------------------------------------------------------------------|---------------------------------|
| Einen Text(block)                                                 | `renderText({})`              |
| Eine Tabelle (stellt z.B. den gesamten Datensatz `community` dar) | `renderTable({community  })`  |
| Eine Visualisierung                                               | `renderPlot({})`                |

Wenn Ihr mehr wissen m√∂chtet, findet Ihr [hier eine gute √úbersicht (auf Englisch)](https://mastering-shiny.org/basic-ui.html#outputs).

#### 3. Das UI (User Interface) 

Damit steht der `server` der App eigentlich schon und wir k√∂nnen uns dem **U**ser **I**nterface (also der UI) der Shiny-App widmen. Das machen wir auch im n√§chsten Schritt. Eine UI ist eigentlich immer nach dem gleichen Prinzip aufgebaut: Wir haben zun√§chst allgemeine Informationen wie das **Thema** oder den **Titel** der Shiny-App (dazu erfahrt Ihr sp√§ter mehr). Dann wird die linke Seitenleiste der Shiny-App programmiert (in `sidebarLayout(sidebarPanel())`) und anschlie√üend werden die Komponenten aus dem Server entsprechend im `mainPanel()` definiert. Das Ganze seht Ihr auch noch einmal an der Visualisierung aus dem Video:

![](https://github.com/CorrelAid/lernplattform/blob/main/daten/abbildungen/app3.png?raw=true){#id .class width=70% height=70%}

Aber eins nach dem anderen. Fangen wir zuerst mit der linken Seitenleiste an. In der Datei `app.R` habt Ihr unter `# 2. Aufgabe` wieder eine detaillierte Anleitung, was Ihr machen m√ºsst, um die App zu f√ºllen. Es gibt wieder verschiedene M√∂glichkeiten, was Ihr als Auswahlm√∂glichkeiten w√§hlt. Ihr k√∂nnt zum Beispiel "Checkboxen" oder "Dropdown-Men√ºs" w√§hlen, um den Nutzer Eurer Shiny-App eine Auswahl treffen zu lassen. 

Wenn Ihr Euch die Shiny-App noch einmal live anschaut, k√∂nnt Ihr sicher die folgende Frage beantworten:

```{r 11filter}
quiz(caption = NULL,
  question("Welche Auswahlm√∂glichkeiten (oder auch Filteroptionen) habt Ihr in der Shiny-App?",
    answer("Man kann nach L√§ndern filtern"),
    answer("Man kann nach Jahren filtern"),
    answer("Man kann nach Kontinenten filtern", correct = TRUE),
    answer("Man kann nach Plastik und Freiwilligen filtern"),
    correct = "Richtig! Und genau das setzen wir jetzt auch um :-)",
    incorrect = "Leider falsch: Versucht es einfach nochmal oder schaut Euch noch einmal die Shiny-App genauer an",
    allow_retry = TRUE,
    try_again_button = "Versucht es nochmal"
  )
)
```

Sehr gut! Dann lasst uns doch die Auswahlm√∂glichkeit in unsere Shiny-App einbauen. Die Tabelle gibt Euch eine kurze √úbersicht, √ºber die wichtigsten Befehls- und Auswahlm√∂glichkeiten:

| Was m√∂chtet Ihr dem Nutzer als Auswahlm√∂glichkeit geben? | Befehl in R (wird in der `ui` implementiert)                                                                                                                                                                    |
|----------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Einen kurzen Freitext                                    | `textInput("id", "Beschreibung")`                                                                                                                                                                               |
| Einen langen Freitext                                    | `textAreaInput("id", "Beschreibung", rows = 3)` Mit `rows` (also Zeilen) geben wir die L√§nge des Textes an                                                                                                      |
| Eine Zahl                                                | `numericInput("id", "Beschreibung", value = 0, min = 0, max = 100)` Mit `value` bestimmen wir den Standardwert, der immer angezeigt wird. Mit ` min` und `max` legen wir die Mindest- und die Maximalwerte fest |
| Eine Zahl (aber mit "Slider-Auswahl")                    | `sliderInput("id", "Beschreibung", value = 0, min = 0, max = 100)`                                                                                                                                              |
| Einfachauswahl aus Liste                                 | `selectInput("id", "Beschreibung", auswahl)` In `auswahl` k√∂nnt Ihr entweder die Auswahl definieren (so wie wir es in √úbung 2 machen) oder Ihr greift auf ein anderes Objekt (in diesem Fall ` auswahl` zu)     |
| Checkbox (mit Mehrfachauswahl)                           | `checkboxGroupInput("id", "Beschreibung", auswahl)`                                                                                                                                                             |

Wenn Ihr mehr wissen m√∂chtet, findet Ihr [hier eine gute √úbersicht (auf Englisch)](https://mastering-shiny.org/basic-ui.html#inputs){target="_blank"}.

Wichtig ist, dass alle Auswahlm√∂glichkeiten nach einem √§hnlichen Schema aufgebaut sind (die Komplexit√§t variiert nat√ºrlich abh√§ngig von der Auswahlm√∂glichkeit, die Ihr gew√§hlt habt):

```
checkboxGroupInput(

      # Hier definiert Ihr eine "id" (das ist wichtig, um den `server` mit der 
      # `ui`) sp√§ter zu verbinden
      "continentSelection", 
                            
      # hier wird die Beschreibung eingef√ºgt
      
      "W√§hlt einen Kontinent aus", 
      
      # Der n√§chste Schritt ist wichtig - hier definieren wir, was der
      # Nutzer ausw√§hlen kann. 
      # Dieser Schritt variiert von Auswahlm√∂glichkeit zu Auswahlm√∂glichkeit.
      # Die Logik ist, dass wir eine Liste (`list`) an M√∂glichkeiten in 
      # `choiches` speichern. Wir m√∂chten hier alle Kontinente ausw√§hlen. 
      # Dazu m√ºssen wir jeden Kontinent sein Anzeige√§quivalent (linke Seite) 
      # und seine Bezeichnung im Datensatz (rechte Seite) geben

      choices = list(
                "Nord- und S√ºdamerika" = "Americas",
                "Afrika" = "Africa",
                "Asien" = "Asia",
                "Europa" = "Europe",
                "Ozeanien" = "Oceania"
      ),
      
      # Oft gibt es dann auch die M√∂glichkeit eine Vorauswahl zu treffen, die 
      # der Nutzer immer angezeigt bekommt - hier nehemn wir `"Americas"` 
      # (also den Namen im Datensatz) :-)

      selected = "Americas"
    )
```

- **`id`**: Wichtig ist, dass die `id` (hier `continentSelection`) nur einmal vergeben wird, damit wir es sp√§ter im Server eindeutig zuordnen k√∂nnen.
- **Beschreibung**: Hier seid Ihr absolut frei und k√∂nnt eine Beschreibung ausw√§hlen, die Euch f√ºr den Nutzer passend erscheint
- **Auswahlm√∂glichkeiten**: Unter `choices` definieren wir hier zum Beispiel eine Liste (`list`), die uns die einzelnen Kontinente im Datensatz ausw√§hlen l√§sst (wenn Ihr es noch einmal √ºberpr√ºfen m√∂chtet, k√∂nnt Ihr Sie Euch mit `table(community$continent)` anzeigen lassen). Was sehr praktisch ist, ist hier die M√∂glichkeit der Benennung innerhalb der Shiny-App (also was der Nutzer in der Shiny-App sieht). Was wir hier zum Beispiel als M√∂glichkeit nutzen k√∂nnen, um deutschsprachige Labels zu vergeben!
- **`selected`**: Im letzten Schritt k√∂nnen wir optional eine Standardauswahl f√ºr den Nutzer festlegen (wir w√§hlen hier `Americas` (also den Namen, der f√ºr den Kontinent im Datensatz vergeben ist))

Und jetzt wenden wir es in der `# 2. Aufgabe` in unserer Shiny-App an! Geht dazu wieder zur `app.R` Datei.

*Eine kurze Anmerkung*: Wir vernachl√§ssigen in diesem Schritt zun√§chst das `mainPanel()` - das kommt gleich :-) 

```{r ui_exercise, exercise=TRUE, eval =FALSE}
# UI ----------------------------------------------------------------------

# Jetzt definieren wir das User Interface (auch UI, also die Benutzeroberfl√§che)
# Hierf√ºr nehmen wir die Vorlage, die uns RStudio liefert und erg√§nzen
# die f√ºr uns relevanten Teile

ui <- fluidPage(
  
  titlePanel(""), # Den Titel lassen wir an dieser Stelle noch ungef√ºllt
   
  # Definiert die Seitenleiste und den Input
  sidebarLayout(sidebarPanel(
    ##########################################################################
    # 2. Aufgabe
    # Wir verwenden hier den `checkboxGroupInput`
    # Das erlaubt uns, ein Input-Men√º zu erstellen, bei dem 
    # wir √ºber "Check-Boxen" die Kontinente ausw√§hlen
    
    checkboxGroupInput(
      
      # Gebt dieser Auswahl einen Namen (wir werden den Namen sp√§ter
      # nutzen, um auf dieses Auswahlmen√º zuzugreifen)
      
      "",
      
      # Gebt eine Anleitung f√ºr den Nutzer ein (das kann sehr kurz sein
      # und zum Beispiel "W√§hle einen Kontinent" umfassen oder aber auch 
      # ausf√ºhrlicher sein - hier seid Ihr vollkommen frei in eurer 
      # Auswahl :-))
      "",
      
      # Der n√§chste Schritt ist wichtig - hier definieren wir, was der
      # Nutzer ausw√§hlen kann. Die Logik ist, dass wir eine Liste (`list`)
      # an M√∂glichkeiten in `choiches` speichern. Wir m√∂chten hier alle
      # Kontinente ausw√§hlen. Dazu m√ºssen wir jeden Kontinent sein
      # Anzeige√§quivalent (linke Seite) und seine Bezeichnung im 
      # Datensatz (rechte Seite) geben

      choices = list(
      ),
      
      # Wir k√∂nnen jetzt noch im letzten Schritt eine Standardvorauswahl 
      # treffen - hier nehemn wir `"Americas"` (also den Namen im Daten-
      # satz) :-)

      selected = ""
    )
    ##########################################################################
    
  ),
  
  mainPanel() # das mainPanel lassen wir an dieser Stelle noch ungef√ºllt
)
```

Wunderbar - unsere Seiteleiste steht jetzt und wir wenden uns jetzt dem `mainPanel()` zu. Die Tabelle sollte Euch bekannt vorkommen - wir haben sie an dieser Stelle nur um eine weitere Spalte erg√§nzt. Wenn Ihr Euch noch einmal an das Video zur√ºckerinnert, haben wir dort gelernt, dass alles miteinander verbunden sein muss, damit die Shiny-App auch funktioniert. Das bezieht sich auf eine entsprechende Einbindung der im `server` generierten Texte, Tabellen oder Visualisierungen. In der dritten Spalte der Tabelle habt Ihr das entsprechende √Ñquivalent, dass Ihr nutzen k√∂nnt, um den "Output" im `mainPanel()` der Shiny-App einzubinden.

| **Was m√∂chtet Ihr darstellen?**                                       | **Befehl in R f√ºr den `server`**    | **Befehl in R f√ºr die `ui` in mainPanel()** |
|-------------------------------------------------------------------|---------------------------------|--------------------------|
| Einen Text(block)                                                 | `renderText({})`              | `textOutput()`          |
| Eine Tabelle (stellt z.B. den gesamten Datensatz `community` dar) | `renderTable({community  })`  | `tableOutput()`          |
| Eine Visualisierung                                               | `renderPlot({})`                | `plotOutput()`          |

Wenn Ihr mehr wissen m√∂chtet, findet Ihr [hier eine gute √úbersicht (auf Englisch)](https://mastering-shiny.org/basic-ui.html#outputs){target="_blank"}.

W√§hlt in Aufgabe 3 (`# 3. Aufgabe` in der `app.R`-Datei) den geeigneten Befehl f√ºr die `ui` aus, um eine Visualisierung (also einen "Plot") darzustellen. Unten seht Ihr wieder den Code, den Ihr auch in der `app.R` sehen solltet.

Wir haben im `server` unser Balkendiagramm in `output$balkendiagramm` gespeichert - das ist hier eine wichtige Information, da wir es hier mit `"balkendiagramm"` direkt ansprechen und einbinden k√∂nnen. Bearbeitet dazu Aufgabe 3 im Code in Eurer `app.R`-Datei.

```{r ui_exercise_choices, exercise=TRUE, eval = FALSE}
# UI ----------------------------------------------------------------------

# Jetzt definieren wir das User Interface (auch UI, also die Benutzeroberfl√§che)
# Hierf√ºr nehmen wir die Vorlage, die uns RStudio liefert und erg√§nzen
# die f√ºr uns relevanten Teile

ui <- fluidPage(

  titlePanel(""),
  
  # Definiert die Seitenleiste und den Input (das haben wir bereits im letzten Schritt getan)
  sidebarLayout(sidebarPanel(
    checkboxGroupInput(
      "",
      h4(""),
      choices = list(
      ),
      selected = ""
    )

  ),
  
  ##########################################################################
  # 3. Aufgabe:
  
  # F√ºgt das Balkendiagramm in `mainPanel()` ein
  # Dazu m√ºsst Ihr zwei Dinge beachten
  
  # 1) W√§hlt eine geeignete Output-Funktion (hier erhaltet Ihr Inspiration 
  # (https://mastering-shiny.org/basic-ui.html#outputs) oder
  # schaut auf der Lernplattform in der √úbersicht - es handelt sich hierbei um
  # einen "plot", den wir darstellen m√∂chten)
  
  # 2) F√ºgt das unten generierte "balkendiagramm" ein (es ist wichtig, dass es
  # in Anf√ºhrungszeichen steht)
  
  # F√ºr die Intuition: Wir greifen hier auf das Objekt ("balkendiagramm") zu, 
  # das Ihr zuvor im `server` generiert habt und lassen es uns ausgeben :-)
  ##########################################################################
  
  mainPanel()
)
```


#### 4. Die Shiny-App zum Laufen bringen

Im letzten Schritt bringen wir in Eurer Shiny-App den `server` und die `ui` zusammen - erinnert Ihr Euch noch, wie das ging? 

```{r 11shinyapp}
quiz(caption = NULL,
  question("Wie bringt man in der Shiny-App den `server` und die `ui` zusammen?",
    answer("Mit `shinyApp(ui = ui, server = server)`", correct = TRUE),
    answer("Gar nicht - wir m√ºssen beide Funktionen einzeln ausf√ºhren und RStudio bringt sie dann zusammen"),
    correct = "Richtig! Und genau das setzen wir jetzt auch um :-)",
    incorrect = "Leider falsch: Versucht es einfach nochmal oder schaut Euch das Video noch einmal an",
    allow_retry = TRUE,
    try_again_button = "Versucht es nochmal"
  )
)
```

Perfekt - setzt es doch gleich in Aufgabe 4 (`# 4. Aufgabe` in der `app.R`-Datei) um! Hier kurz zur Erinnerung wie der Code in der Datei aussehen sollte:

```{r shinyapp_bring_it_together, exercise=TRUE, eval = FALSE}

# Shiny-App zum Laufen bringen --------------------------------------------

##########################################################################
# 4. Aufgabe:
# Wir kombinieren mit dem folgenden Befehl die UI und den Server und bringen
# die Shiny-App lokal zum Laufen :-)
# Nutzt `shinyApp` mit den entsprechenden Argumenten (f√ºgt also die `ui` und
# den `server` ein in die "XXX" ein) und lasst das gesamte Dokument 
# durchlaufen 
##########################################################################

shinyApp(ui = XXX, server = XXX)

```

Jetzt sind wir endlich soweit -- lasst das gesamte Dokument einmal durchlaufen (markiert daf√ºr den gesamten Code und f√ºhrt ihn aus) und probiert Eure Shiny-App auf Eurem Rechner aus. Was f√§llt Euch auf?

```{r 11shinyapp_does_filter_work}
quiz(caption = NULL,
  question("Was f√§llt Euch auf, wenn Ihr Euch die Shiny-App lokal genauer anschaut?",
    answer("Gar nichts - es l√§uft doch alles wunderbar!"),
    answer("Der Filter scheint nicht zu reagieren", correct = TRUE),
    correct = "Richtig! Und genau das beheben wir jetzt im Code :-)",
    incorrect = "Leider falsch: Versucht es einfach nochmal oder schaut Euch die Shiny-App noch einmal genauer an",
    allow_retry = TRUE,
    try_again_button = "Versucht es nochmal"
  )
)
```

Richtig, Euer Filter scheint noch nicht richtig zu funktionieren. Das liegt daran, dass wir den `server` noch nicht mit der `ui` verbunden haben. Erinnert Ihr Euch an die Abbildung im Video, die Euch gezeigt hat, dass alles miteinander verbunden sein muss?

![](https://github.com/CorrelAid/lernplattform/blob/main/daten/abbildungen/app5.png?raw=true){#id .class width=70% height=70%}

Das holen wir jetzt nach. Dazu bauen wir einen Filter in unsere Visualisierungsfunktion im `server` ein. Dazu gehen wir in die Funktion, die wir vorher einfach in unseren `server` reinkopiert haben. Hier zur kurzen Erinnerung der Funktionsaufbau:

![]() **add image with function_call in pseudo code**

Nach der Bearbeitung der Daten und vor der Erstellung der Visualisierung mit `ggplot2` haben wir die M√∂glichkeit noch einen zus√§tzlichen Filter einzubauen. Im Code w√§re das an der gekennzeichnenten Stelle:

```{r make_function_work, exercise=TRUE}
        community %>%
  
            # Datenbereinigung
            dplyr::filter(continent != "Unknown") %>%
            ungroup() %>%
            dplyr::mutate(absolute_anzahl = sum(volunteers)) %>%
            group_by(continent) %>%
            dplyr::mutate(relative_anzahl = (sum(volunteers) / absolute_anzahl) * 100) %>%
            distinct(continent, relative_anzahl)  %>%
            
            ##########################################################################
            # Hier bauen wir einen zus√§tzlichen Filter ein:
            dplyr::filter(continent %in% input$continentSelection) %>%
            ##########################################################################

            # Erstellen des ggplot2-Objekts
            ggplot2::ggplot(aes(
                x = continent,
                y = relative_anzahl,
                fill = continent
            )) +
            geom_col() +
            labs(title = "Prozentuale Verteilung der Freiwilligen" ,
                 subtitle = "pro Kontinent",) +
            scale_fill_manual(values = wes_palette("Cavalcanti1")) +
            ggthemes::theme_wsj() +
            theme(legend.title = element_blank(),
                  text = element_text(size = 7))
```

Wie Ihr seht, w√§hlen wir hier wieder die `dplyr::filter()` Option und definieren so, dass nur die Kontinente ausgew√§hlt werden sollen, die in `input$continentSelection` ausgew√§hlt wurden. Erinnert Ihr Euch noch an die `id`, die wir in der `ui` vergeben haben? Genau hier nutzen wir sie, um darauf im `server` zu verweisen! 

Das ist auch schon unsere 5. Aufgabe in der App - f√ºgt den Code an der entsprechenden Stelle ein und lasst die ganze `app.R`-Datei noch einmal laufen.

```{r make_server_work, exercise=TRUE}
    ##########################################################################
    # 5. Aufgabe:
    # Wichtig! Der Filter lief noch nicht - wieso? 
    # Als zus√§tzlichen Schritt m√ºssen wir jetzt noch einen Filter 
    # einbauen, in dem wir auf unsere Auswahl in der `ui` zugreifen
    # Hierf√ºr k√∂nnt Ihr den Code aus der Lernplattform nehmen und ihn einf√ºgen
    # (Ihr seht in der Lernplattform wo es sinnvoll w√§re)
    ##########################################################################
```

#### 5. Versch√∂nerungen Eurer Shiny-App

Bis hierhin haben wir schon 80% der Shiny-App geschafft - herzlichen Gl√ºckwunsch! Sie l√§uft, zeigt uns zuverl√§ssig √ºber unseren vordefinierten Filter die Balken an, die wir sehen m√∂chten und ist insgesamt auch schon recht professionell. Es w√§re nat√ºrlich noch sch√∂n, wenn wir die Shiny-App noch ein bisschen weiter versch√∂nern k√∂nnten. Dazu gibt es verschiedene M√∂glichkeiten und auch oft schon vordefinierte Packages, die Ihr einfach nutzen k√∂nnt.

**Thema √§ndern**

Wie auch schon in `ggplot2` gibt es verschiedene Themen, die Ihr eurer Shiny-App geben k√∂nnt. Wir nutzen dazu das Package `shinythemes`, das wir mit folgendem Befehl zun√§chst laden:

```{r shinythemes, exercise=TRUE}
# install.packages("shinythemes")
library(shinythemes)
```

Hier gibt es viele verschiedene Themen, die Euch zur Auswahl stehen! Klickt Euch durch die Folien, um eine Idee zu bekommen, wir Eure Shiny-App aussehen k√∂nnte: 

```{r flipbook_themes, out.width='100%', out.height='100%'}
knitr::include_url("https://cosimameyer.rbind.io/slides/flip_for_correlaid_shinythemes/dsee_slides_shinythemes#1")
```

Sollte die Darstellung auf dieser Plattform nicht funktionieren, k√∂nnt Ihr auf die [Folien hier zugreifen](https://cosimameyer.rbind.io/slides/flip_for_correlaid_shinythemes/dsee_slides_shinythemes#1){target="_blank"}.

Wenn Ihr mehr Inspirationen m√∂chtet, schaut einfach [hier](https://rstudio.github.io/shinythemes/){target="_blank"} vorbei.

W√§hlt jetzt ein Thema aus, das Euch gef√§llt und erg√§nzt es in Aufgabe 6 (`# 6.Aufgabe` in der `app.R`-Datei):

```{r shiny_theme_tuning, exercise=TRUE, eval =FALSE}
ui <- fluidPage(
  
  ##########################################################################
  # 6. Aufgabe
  # Jetzt geht es ans Fine-Tuning!
  # √Ñndert das Thema - entkommentiert daf√ºr die Zeile Code und erg√§nzt es mit
  # einem Thema eurer Wahl
  # Holt Euch Inspiration hier: https://rstudio.github.io/shinythemes/
  ##########################################################################
  
  # theme = shinytheme(""),
  
  ...
)
```

Lasst Eure Shiny-App noch einmal lokal laufen und schaut, wie schnell sich die Oberfl√§che der Shiny-App √§ndern kann!

**Titel √§ndern**

Im letzten Schritt geben wir unserer Shiny-App noch einen sch√∂nen Titel, zum Beispiel "Break Free From Plastic". Das erg√§nzen wir auch in der `ui` (in `# 7. Aufgabe` seht Ihr, wo Ihr es erg√§nzen m√ºsst):

```{r ui_title, exercise=TRUE}
ui <- fluidPage(
  
  ##########################################################################
  # 7. Aufgabe
  # √Ñndert den Titel in `titelPanel`
  ##########################################################################
  
  titlePanel(""),
  ...
)
```

Und jetzt lassen wir sie noch einmal final erstellen - markiert dazu wieder den ganzen Code in der `app.R`-Datei und lasst sie durchlaufen. Herzlichen Gl√ºckw√ºnsch zu eurer ersten Shiny-App! Das sieht klasse aus!

### Exkurs 1: Reaktives Programmieren - das Geheimnis einer Shiny-App

Im folgenden Abschnitt lernt Ihr mehr √ºber die Funktionsweise einer Shiny-App. Was ist genau der Algorithmus, der sie zum Laufen bringt? Das ganze Geheimnis hinter der App nennt sich **reactive programming**, oder auch **reaktives Programmieren**. Wie das funktioniert, k√∂nnt Ihr Euch in dem Video ansehen:

![](https://github.com/CorrelAid/lernplattform/blob/main/daten/abbildungen/reactivity.png?raw=true){#id .class width=70% height=70%} 

(ca. 10 Minuten)

*Video zur Reaktivit√§t mit Brieftaube*

**In K√ºrze**: Man kann sich das Verhalten zwischen der UI, dem Server und dem Nutzer wie die Kommunikation mit einer Brieftaube vorstellen. Dieses sch√∂ne Bild stammt von Garrett Grolemund, der sagt, dass Reaktivit√§t eine Illusion erzeugt, die dem Nutzer vermittelt, dass die Nutzereingabe automatisch z.B. Abbildungen kreiert.[^1] 


```{r reactivity_quiz}
quiz(caption = NULL,
  question("Welche Aussagen sind korrekt?",
    answer("Die Reaktivit√§t einer Shiny-App kann mit einer Brieftaube verglichen werden - sie fliegt nur los, wenn sie beauftragt wird.", correct = TRUE),
    answer("Eine Shiny-App ruft die Ganze Zeit die Informationen ab und updated sich die Ganze Zeit im Hintergrund."),
    answer("Die Reaktivit√§t der Shiny-App generiert die Illusion, dass sich die Nutzereingabe automatisch kreiert - dabei handelt es sich in Wirklichkeit um ein Zusammenspiel zwischen Nutzerauswahl, Server und der Ausgabe im User Interface.", correct = TRUE),
    correct = "Richtig!",
    incorrect = "Leider falsch: Versuche es einfach nochmal oder schau im Video nach!",
    allow_retry = TRUE,
    try_again_button = "Nochmal versuchen"
  )
)
```

### Exkurs 2: Hosten von ShinyApps
RStudio bietet einen Hosting-Service f√ºr Eure Shiny-App an, den Ihr f√ºr kleinere Anwendungen kostenlos nutzen k√∂nnt: [ShinyApps.io](https://www.shinyapps.io){target="_blank"}. Eine dort gehostete Anwendung kann dann zum Beispiel [so aussehen](https://cosima-meyer.shinyapps.io/conflict-elections/){target="_blank"} und, wie im Beispiel visuell, die Gewaltentwicklung vor Wahlen in Afghanistan darstellen. 

In jedem Fall sollte intern abgekl√§rt werden, ob diese Hosting-Option f√ºr Euch in Frage kommt oder ob es nicht eine alternative √ºber die IT-Abteilung gibt (z.B. bei sensiblen Daten).

Sollte die RStudio-L√∂sung f√ºr Euch eine Option sein, ist das Hosten denkbar einfach. Ihr m√ºsst nur die folgenden Schritte befolgen:

1. Alle Packages m√ºssen installiert sein und nur √ºber `library()` geladen werden. D.h. Euer Code darf kein `install.packages()` enthalten.

2. Dann m√ºsst Ihr `rsconnect` installieren (das macht Ihr ganz einfach √ºber die Console mit `install.packages("rsconnect")`)

3. Danach erstellt Ihr Euch einen Account auf [ShinyApps.io](https://www.shinyapps.io){target="_blank"} (es gibt verschiedene Optionen, w√§hlt den Account aus, der am besten zu euren Bed√ºrfnissen passt)

4. Jetzt k√∂nnt Ihr `rsconnect` konfigurieren. Dazu m√ºsst Ihr den Token, den Euch [ShinyApps.io](https://www.shinyapps.io){target="_blank"} zur Verf√ºgung stellt, kopieren. Die Screenshots zeigen Euch, wie Ihr dahin kommt.

Sobald Ihr Euch bei [ShinyApps.io](https://www.shinyapps.io){target="_blank"} eingeloggt habt, seht Ihr folgendes Dashboard: 

![](https://github.com/CorrelAid/lernplattform/blob/main/daten/abbildungen/shinyapps1.png?raw=true){#id .class width=70% height=70%}

Dort klickt Ihr auf Euer Benutzerkonto (rechts oben) und dann auf "Tokens" und gelangt zu folgendem Fenster:

![](https://github.com/CorrelAid/lernplattform/blob/main/daten/abbildungen/shinyapps2.png?raw=true){#id .class width=70% height=70%}

Wenn Ihr jetzt auf "+ Add Token" klickt, wird ein neues Token generiert und erscheint in der Auflistung. Um die Informationen zu bekommen, die Ihr f√ºr Eure Shiny-App braucht, klickt einfach auf "üëÅ Show". Dann √∂ffnet sich ein kleines Pop-up Fenster mit allen wichtigen Infos, die Ihr einfach kopieren k√∂nnt (klickt dazu auf "üìé Copy to clipboard").

![](https://github.com/CorrelAid/lernplattform/blob/main/daten/abbildungen/shinyapps3.png?raw=true){#id .class width=70% height=70%}

5. Nachdem Ihr den Code kopiert habt, verkn√ºpft Eure Shiny-App mit [ShinyApps.io](https://www.shinyapps.io){target="_blank"}, indem Ihr den Code in der Console einf√ºgt und ausf√ºhrt. 

6. Ihr k√∂nnt Eure Shiny-App noch vor dem finalen Deployen testen, indem Ihr in der Console `runApp()` ausf√ºhrt.

7. Hat alles geklappt? Dann kommt das Deployen! F√ºhrt in der Console einfach `deployApp()` aus und wartet ein bisschen - Eure Shiny-App ist nach ein bisschen Warten direkt online und kann √ºber einen Link aufgerufen werden!


```{r 11deployment}
quiz(caption = NULL,
  question("Was sind die wichtigen Schritte, die Ihr beim Deployen Eurer Shiny-App beachten m√ºsst?",
    answer("Ihr solltet sowohl `install.packages` als auch `library` Aufrufe in Eurer `app.R`-Datei haben."),
    answer("Es d√ºrfen keine `install.packages`-Funktionen in Eurer `app.R`-Datei sein.", correct = TRUE),
    answer("Ihr braucht ein sogenanntes Token von shinyapps.io.", correct = TRUE),
    answer("Ihr m√ºsst eine Verbindung zwischen shinyapps.io und RStudio mit Hilfe von `rsconnect` herstellen.", correct = TRUE),
    answer("Ihr m√ºsst eigentlich nichts weiter beachten oder einstellen - es reicht, wenn Ihr `deployApp()` laufen lasst."),
    correct = "Richtig!",
    incorrect = "Leider falsch: Versuche es einfach nochmal oder lest Euch noch einmal die Beschreibung durch.",
    allow_retry = TRUE,
    try_again_button = "Nochmal versuchen"
  )
)
```

### Und jetzt seid Ihr dran! (diese Woche optional)

Ihr habt jetzt das wichtigste Grundwerkzeug gelernt, um eine Shiny-App lokal zu erstellen -- und genau das k√∂nnt Ihr in dieser √úbung mit euren Daten umsetzen! Ziel ist es, eine einfache Shiny-App zu erstellen. Dazu k√∂nnt Ihr beispielsweise eine Visualisierung aus einer vorherigen √úbung in eine Shiny-App einbinden oder eine Tabelle anzeigen lassen - eurer Phantasie sind keine Grenzen gesetzt! Jede Shiny-App f√§ngt simpel an und kann dann durch die einzelnen Bausteine beliebig erweitert werden. 
Hier die Schritte, die Ihr zum Erstellen einer Shiny-App befolgen solltet:

1. W√§hlt Euch eine Visualisierung (z.B. mit `ggplot2` oder aber auch mit `echarts4r`)  mit euren Daten aus (idealerweise habt Ihr schon Code, den Ihr jetzt einfach wieder benutzen k√∂nnt - zum Beispiel aus der letzten Woche. Wenn Ihr keinen Code bereit habt, haben wir zwei m√∂gliche Visualisierungen (eine Punktewolke und eine Karte) f√ºr Euch vorbereitet, die Ihr nutzen k√∂nnt und damit die folgenden Schritte √ºben k√∂nnt.)

2. √ñffnet RStudio und w√§hlt dort eine neue Datei aus -- w√§hlt dort "Shiny Web App". 

![](https://github.com/CorrelAid/lernplattform/blob/main/daten/abbildungen/shiny_step1.png?raw=true){#id .class width=50% height=50%}

Gebt eurer Shiny-App einen geeigneten Namen. W√§hlt dort die Variante mit einer Datei ("Single File (app.R)"), d.h.  es wird eine Datei sowohl f√ºr die UI (`ui.R`) als auch f√ºr den Server (`server.R`) erstellt) aus. 

![](https://github.com/CorrelAid/lernplattform/blob/main/daten/abbildungen/shiny_step2.png?raw=true){#id .class width=50% height=50%}

3. √úberlegt Euch, wie Eure Shiny-App aussehen soll. Eine Shiny-App hat meist links eine Seitenleiste mit Auswahlm√∂glichkeiten, in der Mitte (dem `main`-Part) ist meist Text, eine Visualisierung oder aber auch eine Tabelle. Es kann helfen, wenn Ihr Euch das kurz auf einem Papier visuell skizziert: Welche Visualisierung m√∂chtet Ihr in Eure Shiny-App einbinden? Was k√∂nnten Auswahlm√∂glichkeiten sein, die Ihr in der Seitenleiste ansteuern m√∂chtet? M√∂chtet Ihr Text als Informationen mitliefern?

4. Nehmt euren Code f√ºr die Visualisierung (wenn Ihr noch keinen Code habt erstellt zun√§chst eine Visualisierung mit `ggplot2` und nutzt diesen Code hier) und baut ihn in die `server.R`-Datei ein. Orientiert Euch hier an der Anleitung oben oder aber auch am [Schummelzettel](daten/cheat sheets/shiny_de.pdf){target="_blank"}.

5. Im vorletzten Schritt versch√∂nern wir das Aussehen eurer App in der `ui.R`-Datei: Baut die einzelnen Auswahlm√∂glichkeiten in die Seitenleiste ein und platziert Eure Visualisierung oder euren Text im `main`-Part. 

6. Wenn Ihr m√∂chtet, k√∂nnt Ihr Eure Shiny-App √ºber ein `theme` noch weiter versch√∂nern. [Hier](https://rstudio.github.io/shinythemes/){target="_blank"} findet Ihr eine Liste an Auswahlm√∂glichkeiten. Um es umzusetzen, installiert `install.packages("shinythemes")` und f√ºgt in die `fluidPage` Euer pr√§feriertes Design hinzu (z.B. `fluidPage(theme = shinytheme("cerulean"), ...)`).

7. Und jetzt kommt der spannendste Part: Lasst Eure Shiny-App laufen! F√ºhrt dazu `shinyApp(ui = ui, server = server)` in der Console aus. Eure App wird sich in einem separaten Fenster √∂ffnen und Ihr k√∂nnt sie direkt ausprobieren :-)

### Weitere Ressourcen
  - [Schummelzettel Shiny-Apps (auf Deutsch)](daten/cheat sheets/shiny_de.pdf){target="_blank"}
  - [R Studio tutorial (auf Englisch)](https://shiny.rstudio.com/tutorial/){target="_blank"}
  - [Hadley Wickham: Mastering Shiny (auf Englisch)](https://mastering-shiny.org){target="_blank"}
  - [Konstantin Gavras and Nick Baumann: Shiny Apps: Development and Deployment (auf Englisch)](https://www.mzes.uni-mannheim.de/socialsciencedatalab/article/shiny-apps/){target="_blank"} auf Methods Bites
  - [Julie Scholler: Intro to Shiny Web App (auf Englisch)](https://juliescholler.gitlab.io/files/M2/M2-CM3-Shiny.html#1){target="_blank"}
  - [Kaleen L. Medeiros: Introduction to Shiny (auf Englisch)](https://github.com/klmedeiros/rladies-tunisia-july2020-intro-shiny){target="_blank"}
  - [Garrett Grolemund: How to understand reactivity in R (auf Englisch)](https://shiny.rstudio.com/articles/understanding-reactivity.html){target="_blank"}
- ShinyApps hosten
  - [Hosting and deployment (auf Englisch)](https://shiny.rstudio.com/articles/shinyapps.html){target="_blank"}
  - [Shinyapps.io - Schritt f√ºr Schritt Anleitung (auf Englisch)](https://shiny.rstudio.com/articles/shinyapps.html){target="_blank"}
- Mehr zu **echarts4r** 
  - [echarts4r vignette (auf Englisch)](https://echarts4r.john-coene.com/index.html){target="_blank"}
  - [Paul Simmering: Exploring `echarts4r` (auf Englisch)](https://rpubs.com/paul_simmering/echarts){target="_blank"}

- Shiny dashboards
  - [R Studio Tutorial (auf Englisch)](https://rstudio.github.io/shinydashboard/){target="_blank"}
  - [Verschiedene "Themes" (auf Englisch)](https://github.com/nik01010/dashboardthemes){target="_blank"}

- Optimieren von ShinyApps
  - [Make your Shiny-App faster (auf Englisch) (auf Englisch)](https://appsilon.com/r-shiny-faster-updateinput-css-javascript/){target="_blank"}
  - [shiny.worker](https://www.r-bloggers.com/shiny-worker-speed-up-r-shiny-apps-by-offloading-heavy-calculations/){target="_blank"}
  
[^1]: ["Reactivity creates the illusion that changes in input values automatically flow to the plots, text, and tables that use the input‚Äîand cause them to update." (Garrett Grolemund)](https://shiny.rstudio.com/articles/understanding-reactivity.html)